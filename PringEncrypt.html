<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PringEncrypt</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <main>
    <h1>PringEncrypt! (please stop leaking our stuffâ„¢)</h1>

    <section class="box">
      <h2>Key</h2>
      <div class="row">
        <button id="genKeyBtn">Generate 256-bit key</button>
        <button id="copyKeyBtn">Copy key</button>
      </div>
      <label for="keyInput">AES key (Base64):</label>
      <textarea id="keyInput" placeholder="Base64 key"></textarea>
      <div class="note">
        Key must be 32 bytes (256 bits) when decoded. You can paste your own Base64 key here OR generate one (recommended)
      </div>
    </section>

    <section class="box">
      <h2>Encrypt</h2>
      <input id="fileInput" type="file" />
      <div class="row">
        <button id="encryptBtn">Encrypt</button>
      </div>
      <div id="encryptStatus" class="status"></div>
    </section>

    <section class="box">
      <h2>Decrypt (.bin)</h2>
      <input id="binInput" type="file" accept=".bin" />
      <div class="row">
        <button id="decryptBtn">Decrypt (.bin)</button>
      </div>
      <div id="decryptStatus" class="status"></div>
    </section>

    <footer>
      <small>All crypto is done locally in your browser using Web Crypto API (AES-GCM 256-bit).</small>
    </footer>
  </main>

  <script>

    function bufToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = "";
      for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }
    function base64ToBuf(b64) {
      const binary = atob(b64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    }
    function concatArrayBuffers(...buffers) {
      const total = buffers.reduce((s, b) => s + b.byteLength, 0);
      const tmp = new Uint8Array(total);
      let offset = 0;
      for (const b of buffers) {
        tmp.set(new Uint8Array(b), offset);
        offset += b.byteLength;
      }
      return tmp.buffer;
    }
    function u32ToBigEndian(val) {
      const a = new Uint8Array(4);
      a[0] = (val >>> 24) & 0xff;
      a[1] = (val >>> 16) & 0xff;
      a[2] = (val >>> 8) & 0xff;
      a[3] = val & 0xff;
      return a.buffer;
    }
    function bigEndianToU32(buf) {
      const a = new Uint8Array(buf);
      return (a[0]<<24) | (a[1]<<16) | (a[2]<<8) | a[3];
    }

    const genKeyBtn = document.getElementById('genKeyBtn');
    const copyKeyBtn = document.getElementById('copyKeyBtn');
    const keyInput = document.getElementById('keyInput');
    const fileInput = document.getElementById('fileInput');
    const encryptBtn = document.getElementById('encryptBtn');
    const encryptStatus = document.getElementById('encryptStatus');
    const binInput = document.getElementById('binInput');
    const decryptBtn = document.getElementById('decryptBtn');
    const decryptStatus = document.getElementById('decryptStatus');

    genKeyBtn.addEventListener('click', async () => {
      try {
        const key = await window.crypto.subtle.generateKey(
          { name: "AES-GCM", length: 256 },
          true,
          ["encrypt", "decrypt"]
        );
        const raw = await window.crypto.subtle.exportKey("raw", key);
        keyInput.value = bufToBase64(raw);
      } catch (err) {
        alert("Key generation failed: " + err);
      }
    });

    copyKeyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(keyInput.value);
        copyKeyBtn.textContent = "Copied!";
        setTimeout(() => (copyKeyBtn.textContent = "Copy key"), 1200);
      } catch {
        alert("Clipboard not available.");
      }
    });

    async function importKeyFromBase64(b64) {
      try {
        const raw = base64ToBuf(b64.trim());
        if (raw.byteLength !== 32) throw new Error("Key must be 32 bytes (256 bits)");
        return await window.crypto.subtle.importKey(
          "raw", raw,
          { name: "AES-GCM" }, false, ["encrypt","decrypt"]
        );
      } catch (e) {
        throw new Error("Invalid key: " + e.message);
      }
    }

    encryptBtn.addEventListener('click', async () => {
      encryptStatus.textContent = "";
      const file = fileInput.files[0];
      if (!file) { encryptStatus.textContent = "Choose a file to encrypt."; return; }
      const keyB64 = keyInput.value.trim();
      if (!keyB64) { encryptStatus.textContent = "Provide or generate a Base64 key first."; return; }

      try {
        encryptStatus.textContent = "Importing key...";
        const key = await importKeyFromBase64(keyB64);

        encryptStatus.textContent = "Reading file...";
        const fileBuffer = await file.arrayBuffer();

        encryptStatus.textContent = "Encrypting...";
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const algo = { name: "AES-GCM", iv: iv };

        const ct = await window.crypto.subtle.encrypt(algo, key, fileBuffer);

        const encName = new TextEncoder().encode(file.name);
        const nameLenBuf = u32ToBigEndian(encName.byteLength);
        const outBuf = concatArrayBuffers(nameLenBuf, encName.buffer, iv.buffer, ct);
        const blob = new Blob([outBuf], { type: "application/octet-stream" });

        const outName = file.name + ".bin";
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = outName;
        document.body.appendChild(a);
        a.click();
        a.remove();
        encryptStatus.textContent = "Encrypted and downloaded: " + outName;
      } catch (e) {
        console.error(e);
        encryptStatus.textContent = "Error: " + e.message;
      }
    });

    decryptBtn.addEventListener('click', async () => {
      decryptStatus.textContent = "";
      const file = binInput.files[0];
      if (!file) { decryptStatus.textContent = "Choose a .bin file to decrypt."; return; }
      const keyB64 = keyInput.value.trim();
      if (!keyB64) { decryptStatus.textContent = "Provide or generate a Base64 key first."; return; }

      try {
        decryptStatus.textContent = "Importing key...";
        const key = await importKeyFromBase64(keyB64);

        decryptStatus.textContent = "Reading .bin...";
        const buf = await file.arrayBuffer();
        const u8 = new Uint8Array(buf);

        if (u8.byteLength < 4 + 12 + 1) throw new Error("File too short / invalid format.");

        const nameLen = bigEndianToU32(u8.slice(0,4));
        if (4 + nameLen + 12 > u8.byteLength) throw new Error("Invalid filename length / corrupted file.");

        const nameBytes = u8.slice(4, 4 + nameLen);
        const filename = new TextDecoder().decode(nameBytes);

        const ivStart = 4 + nameLen;
        const iv = u8.slice(ivStart, ivStart + 12);
        const ct = buf.slice(ivStart + 12);

        decryptStatus.textContent = "Decrypting...";
        const plain = await window.crypto.subtle.decrypt(
          { name: "AES-GCM", iv: iv },
          key,
          ct
        );

        const blob = new Blob([plain], { type: "application/octet-stream" });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        decryptStatus.textContent = "Decrypted and downloaded: " + filename;
      } catch (e) {
        console.error(e);
        decryptStatus.textContent = "Error: " + e.message;
      }
    });
  </script>
</body>
</html>
